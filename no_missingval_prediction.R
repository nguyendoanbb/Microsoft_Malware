library(data.table) #compare to using read_csv, fread cut down importing time from 237.495 to 111.126 seconds, a huge improvement
train <- fread("train.csv", drop = 'MachineIdentifier', data.table = F)

tr.randomObs <- sample(c(1:nrow(train)), 2000000, replace = TRUE)

train1 <- train[tr.randomObs,]

remove(tr.randomObs); invisible(gc())
##########################################################################################
#check for NA values and remove features with most NA
na.count <- sapply(train1, FUN = function(x) sum(is.na(x)))
na.table <- data.frame(features = names(train1), na.percent = round((na.count/dim(train1)[1])*100,4),
                       row.names = NULL)
na.table[order(na.table$na.percent, decreasing = T),]

na.name <- as.vector(na.table$features[na.table$na.percent > 80])

train2 <- train1[,-which(names(train1) %in% na.name)]

remove(na.count, na.table, na.name, train1); invisible(gc())
##########################################################################################

##########################################################################################
#check for skewness
install.packages("moments")
library(moments)
library(dplyr)
numericVar <- train1 %>%  select_if(is.numeric)

skew.value <- sapply(numericVar, FUN = function(x) skewness(x, na.rm = TRUE))
skew.table <- data.frame(features = names(numericVar),
                         skew.value = round(skew.value, 4), row.names = NULL)
skew.table[order(skew.table$skew.value, decreasing = T),]
a <- skew.table[skew.table$skew.value>3,]$features

#positive skew
for (i in a){
  cat("Distribution for", i)
  print(table(train1[,i], useNA = "always"))
  cat("\n")
}

#negative skew
b <- skew.table[skew.table$skew.value < -3,]$features
for (i in b){
  cat("Distribution for", i)
  print(table(train1[,i], useNA = "always"))
  cat("\n")
}
remove(skew.value, skew.table, a, b)
##########################################################################################

##########################################################################################
#cleaning data
#UacLenable should have only binary values
train2$UacLuaenable[train2$UacLuaenable == 2|train2$UacLuaenable == 3|
                      train2$UacLuaenable == 5|train2$UacLuaenable == 48|
                      train2$UacLuaenable == 49|train2$UacLuaenable == 255|
                      train2$UacLuaenable == 6357062|train2$UacLuaenable == 7798884|
                      train2$UacLuaenable == 16777216] <- NA
table(train2$UacLuaenable, useNA = "always") #no more non-binary values

#Smartscreen has several same values but with different cases, need to combine them
train2$SmartScreen[train2$SmartScreen=="off"|train2$SmartScreen=="OFF"] <- "Off"
train2$SmartScreen[train2$SmartScreen=="on"] <- "On"
train2$SmartScreen[train2$SmartScreen=="prompt"|train2$SmartScreen=="Promt"] <- "Prompt"
train2$SmartScreen[train2$SmartScreen=="requireadmin"|train2$SmartScreen=="requireAdmin"] <- "RequireAdmin"
train2$SmartScreen[train2$SmartScreen=="warn"] <- "Warn"
table(train2$SmartScreen, useNA = "always") #values change correctly

#Census_InternalBatteryType
train2$Census_InternalBatteryType[train2$Census_InternalBatteryType == "unkn"|
                                    train2$Census_InternalBatteryType == "n/a"] <- NA
table(train2$Census_InternalBatteryType, useNA = "always") #changes values correctly

#Census_OSWUAutoUpdateOptionsName: change UNKNOWN to NA
train2$Census_OSWUAutoUpdateOptionsName[train2$Census_OSWUAutoUpdateOptionsName == "UNKNOWN"] <- NA
table(train2$Census_OSWUAutoUpdateOptionsName, useNA = "always")

#Census_GenuineStateName: change UNKNOWN to NA
train2$Census_GenuineStateName[train2$Census_GenuineStateName == "UNKNOWN"] <- NA
table(train2$Census_GenuineStateName, useNA = "always")
#Census_FlightRing: change Unknown to NA
train2$Census_FlightRing[train2$Census_FlightRing=="Unknown"|
                           train2$Census_FlightRing=="Invalid"] <- NA
table(train2$Census_FlightRing, useNA = "always")
#Census_ChassisTypeName: change UNKNOWN, Unknown to NA
train2$Census_ChassisTypeName[train2$Census_ChassisTypeName=="UNKNOWN"|
                                train2$Census_ChassisTypeName=="Unknown"] <- NA
table(train2$Census_ChassisTypeName, useNA = "always")
#Census_PrimaryDiskTypeName: change UNKNOWN, Unspecified, Invalid to NA
train2$Census_PrimaryDiskTypeName[train2$Census_PrimaryDiskTypeName=="UNKNOWN"|
                                    train2$Census_PrimaryDiskTypeName=="Unspecified"|
                                    train2$Census_PrimaryDiskTypeName=="Invalid"] <- NA
table(train2$Census_PrimaryDiskTypeName, useNA = "always")

invisible(gc())
##########################################################################################

##########################################################################################
#training with set that eliminated skewed data machine ID
no.skew <- subset(train2, select = -c(MachineIdentifier,Census_IsWIMBootEnabled,
                                      Census_PrimaryDiskTotalCapacity,
                                      IsBeta, Census_IsFlightsDisabled,Census_IsFlightingInternal,
                                      AutoSampleOptIn,Census_ThresholdOptIn,SMode,
                                      Census_IsPortableOperatingSystem))
name <- names(which(sapply(no.skew, is.character)))
for (i in name){
  no.skew[,i] <- as.integer(as.factor(no.skew[,i]))
}

##########################################################################################
library(lightgbm)

train2.y <- train2$HasDetections

#---------------------------
cat("Converting character columns to numeric...\n")

for(feat in names(train2[,-length(train2)])){
  if(is.character(train2[,feat]) == TRUE){
    train2[,feat] <- as.integer(as.factor(train2[,feat]))
    invisible(gc())
  }
}
rm(feat)
#---------------------------
cat("Preparing data...\n")

categorical_feature <- c("ProductName","EngineVersion","AppVersion","AvSigVersion","Platform","Processor","OsVer",
                         "OsPlatformSubRelease","OsBuildLab","SkuEdition","Census_MDC2FormFactor","Census_DeviceFamily","Census_PrimaryDiskTypeName",
                         "Census_ChassisTypeName","Census_PowerPlatformRoleName","Census_OSArchitecture","Census_OSBranch","Census_OSEdition",
                         "Census_OSSkuName","Census_OSInstallTypeName","Census_GenuineStateName","Census_ActivationChannel","Census_FlightRing")

tri <- caret::createDataPartition(train2.y, p = 0.8, list = F)
train2.matrix <- data.matrix(train2[,-length(train2)])
train2.lgb <- lgb.Dataset(data = train2.matrix[tri, ], label = train2.y[tri],categorical_feature =categorical_feature)
val.lgb <- lgb.Dataset(data = train2.matrix[-tri, ], label = train2.y[-tri],categorical_feature =categorical_feature)

rm(tri, categorical_feature, train2.y); invisible(gc())

#---------------------------
cat("Training model...\n")

p <- list(boosting_type = "gbdt",
          objective = "binary",
          metric ="auc",
          nthread = 4,
          learning_rate = 0.05,
          max_depth = -1, #-1 indicates no specified max_depth for tree 
          num_leaves = 20,
          sub_feature = 0.8, #fraction of features used for growing trees
          sub_row = 0.7, #fraction of data to be used for each iteration
          bagging_freq = 1,
          lambda_l1 = 0.1,
          lambda_l2 = 0.1)

m_gbm <- lgb.train(params = p, data = train2.lgb, nrounds = 10000, valids = list(val = val.lgb), 
                   eval_freq = 100, early_stopping_rounds = 20, verbose = 1)
#eval_freq: evaluation output frequency print, only effect when verbose > 0

imp <- lgb.importance(model = m_gbm)
lgb.plot.importance(imp, top_n = 30, cex = 0.75)

no_missingval_score <- m_gbm$best_score

rm(train2.lgb, val.lgb, imp); invisible(gc())

#---------------------------
cat("Preparing test data...\n")

test <- fread('test.csv', drop = 'MachineIdentifier', data.table = F)

te.randomObs <- sample(c(1:nrow(test)), 1000000, replace = TRUE)

test1 <- test[te.randomObs,]

for(feat in names(test1)){
  if(is.character(test1[,feat]) == TRUE){
    test1[,feat] <- as.integer(as.factor(test1[,feat]))
    invisible(gc())
  }
}

rm(feat, te.randomObs); invisible(gc())

test1.matrix <- data.matrix(test1)

prediction <- predict(m_gbm, test1.matrix)

prediction <- ifelse(prediction > 0.5, 1, 0)
table(prediction)
#---------------------------
