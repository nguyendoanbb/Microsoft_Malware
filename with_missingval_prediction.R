library(data.table) #compare to using read_csv, fread cut down importing time from 237.495 to 111.126 seconds, a huge improvement
train <- fread("train.csv", drop = 'MachineIdentifier', data.table = F)

tr.randomObs <- sample(c(1:nrow(train)), 4000000, replace = TRUE)

train1 <- train

remove(tr.randomObs); invisible(gc())
##########################################################################################
#check for NA values
na.count <- sapply(train1, FUN = function(x) sum(is.na(x)))
na.table <- data.frame(features = names(train1), na.percent = round((na.count/dim(train1)[1])*100,4),
                       row.names = NULL)
na.table[order(na.table$na.percent, decreasing = T),]
remove(na.count, na.table)
##########################################################################################

##########################################################################################
#cleaning data
#UacLenable should have only binary values
train1$UacLuaenable[train1$UacLuaenable == 2|train1$UacLuaenable == 3|
                      train1$UacLuaenable == 5|train1$UacLuaenable == 48|
                      train1$UacLuaenable == 49|train1$UacLuaenable == 255|
                      train1$UacLuaenable == 6357062|train1$UacLuaenable == 7798884|
                      train1$UacLuaenable == 16777216] <- NA
table(train1$UacLuaenable, useNA = "always") #no more non-binary values

#Smartscreen has several same values but with different cases, need to combine them
train1$SmartScreen[train1$SmartScreen=="off"|train1$SmartScreen=="OFF"] <- "Off"
train1$SmartScreen[train1$SmartScreen=="on"] <- "On"
train1$SmartScreen[train1$SmartScreen=="prompt"|train1$SmartScreen=="Promt"] <- "Prompt"
train1$SmartScreen[train1$SmartScreen=="requireadmin"|train1$SmartScreen=="requireAdmin"] <- "RequireAdmin"
train1$SmartScreen[train1$SmartScreen=="warn"] <- "Warn"
table(train1$SmartScreen, useNA = "always") #values change correctly

#Census_InternalBatteryType
train1$Census_InternalBatteryType[train1$Census_InternalBatteryType == "unkn"|
                                    train1$Census_InternalBatteryType == "n/a"] <- NA
table(train1$Census_InternalBatteryType, useNA = "always") #changes values correctly

#Census_OSWUAutoUpdateOptionsName: change UNKNOWN to NA
train1$Census_OSWUAutoUpdateOptionsName[train1$Census_OSWUAutoUpdateOptionsName == "UNKNOWN"] <- NA
table(train1$Census_OSWUAutoUpdateOptionsName, useNA = "always")

#Census_GenuineStateName: change UNKNOWN to NA
train1$Census_GenuineStateName[train1$Census_GenuineStateName == "UNKNOWN"] <- NA
table(train1$Census_GenuineStateName, useNA = "always")
#Census_FlightRing: change Unknown to NA
train1$Census_FlightRing[train1$Census_FlightRing=="Unknown"|
                           train1$Census_FlightRing=="Invalid"] <- NA
table(train1$Census_FlightRing, useNA = "always")
#Census_ChassisTypeName: change UNKNOWN, Unknown to NA
train1$Census_ChassisTypeName[train1$Census_ChassisTypeName=="UNKNOWN"|
                                train1$Census_ChassisTypeName=="Unknown"] <- NA
table(train1$Census_ChassisTypeName, useNA = "always")
#Census_PrimaryDiskTypeName: change UNKNOWN, Unspecified, Invalid to NA
train1$Census_PrimaryDiskTypeName[train1$Census_PrimaryDiskTypeName=="UNKNOWN"|
                                    train1$Census_PrimaryDiskTypeName=="Unspecified"|
                                    train1$Census_PrimaryDiskTypeName=="Invalid"] <- NA
table(train1$Census_PrimaryDiskTypeName, useNA = "always")

invisible(gc())
##########################################################################################

##########################################################################################
library(lightgbm)

train1.y <- train1$HasDetections
train1$HasDetections <- NULL

#---------------------------
cat("Converting character columns to numeric...\n")

for(feat in names(train1)){
  if(is.character(train1[,feat]) == TRUE){
    train1[,feat] <- as.integer(as.factor(train1[,feat]))
    invisible(gc())
  }
}
rm(feat)
#---------------------------
cat("Preparing data...\n")

categorical_feature <- c("ProductName","EngineVersion","AppVersion","AvSigVersion","Platform","Processor","OsVer",
                         "OsPlatformSubRelease","OsBuildLab","SkuEdition","Census_MDC2FormFactor","Census_DeviceFamily","Census_PrimaryDiskTypeName",
                         "Census_ChassisTypeName","Census_PowerPlatformRoleName","Census_OSArchitecture","Census_OSBranch","Census_OSEdition",
                         "Census_OSSkuName","Census_OSInstallTypeName","Census_GenuineStateName","Census_ActivationChannel","Census_FlightRing")

tri <- caret::createDataPartition(train1.y, p = 0.8, list = F)
train1.matrix <- data.matrix(train1)
train1.lgb <- lgb.Dataset(data = train1.matrix[tri, ], label = train1.y[tri],categorical_feature =categorical_feature)
val.lgb <- lgb.Dataset(data = train1.matrix[-tri, ], label = train1.y[-tri],categorical_feature =categorical_feature)

rm(tri, categorical_feature, train1.y); invisible(gc())

#---------------------------
cat("Training model...\n")

p <- list(boosting_type = "gbdt",
          objective = "binary",
          metric ="auc",
          nthread = 4,
          learning_rate = 0.05,
          max_depth = -1, #-1 indicates no specified max_depth for tree 
          num_leaves = 20,
          sub_feature = 0.8, #fraction of features used for growing trees
          sub_row = 0.7, #fraction of data to be used for each iteration
          bagging_freq = 1,
          lambda_l1 = 0.1,
          lambda_l2 = 0.1)

m_gbm <- lgb.train(params = p, data = train1.lgb, nrounds = 1000, valids = list(val = val.lgb), 
                   eval_freq = 100, early_stopping_rounds = 20, verbose = 1)

imp <- lgb.importance(model = m_gbm)
lgb.plot.importance(imp, top_n = 30, cex = 0.75)

missingval_score <- m_gbm$best_score

rm(train1.lgb, val.lgb, imp); invisible(gc())

#---------------------------
cat("Preparing test data...\n")

test <- fread('test.csv', drop = 'MachineIdentifier', data.table = F)

te.randomObs <- sample(c(1:nrow(test)), 1000000, replace = TRUE)

test1 <- test[te.randomObs,]

for(feat in names(test1)){
  if(is.character(test1[,feat]) == TRUE){
    test1[,feat] <- as.integer(as.factor(test1[,feat]))
    invisible(gc())
  }
}

rm(feat, te.randomObs); invisible(gc())

test1.matrix <- data.matrix(test1)

prediction <- predict(m_gbm, test1.matrix)

prediction <- ifelse(prediction > 0.5, 1, 0)
table(prediction)
#---------------------------
